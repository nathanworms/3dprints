# Import Blender Python module
import bpy
import math

# --- Configuration Parameters ---

# 1. Board Definition
board_config = {
    "name": "NodeMCU_Amica",
    "pins_per_row": 15,
    "pin_pitch": 2.54,  # mm
    "row_spacing": 22.86,  # mm (centerline to centerline of the two rows)
    # Pin naming: (Row_Index (0 or 1), Pin_Index_in_Row (0 to 14 from one end))
    # THIS PIN MAP IS CRUCIAL AND MUST BE VERIFIED/ADJUSTED FOR YOUR EXACT BOARD
    # Assuming Row 0 is one side, Row 1 is the other.
    # Pin indices 0-14 could be, for example, right-to-left if USB is on the left.
    "pin_map": {
        # Row 0
        "A0": (0, 0), "RSV1": (0, 1), "RSV2": (0, 2), "SD3": (0, 3),
        "SD2": (0, 4), "SD1": (0, 5), "CMD": (0, 6), "SD0": (0, 7),
        "CLK": (0, 8), "GND1": (0, 9), "3V3_1": (0, 10), "EN": (0, 11),
        "RST": (0, 12), "GND2": (0, 13), "VIN": (0, 14),
        # Row 1
        "D0": (1, 0), "D1": (1, 1), "D2": (1, 2), "D3": (1, 3),
        "D4": (1, 4), "D5": (1, 5), "D6": (1, 6), "D7": (1, 7),
        "D8": (1, 8), "RX": (1, 9), "TX": (1, 10), "GND3": (1, 11),
        "3V3_2": (1, 12), "SK1": (1, 13), "SK2": (1, 14) # SK often means no connect
    }
}
# Add other board configs here later e.g., LoLin

flip_model_for_printing = True # Or False if you want the original orientation

# 2. Shroud Design Parameters
pin_actual_exposed_length = 6.0  # mm
pin_depth_clearance = 0.5      # mm (extra depth for pin holes beyond actual pin length)
top_surface_thickness = 1.5    # mm (thickness of the material above where standard pins end)

standard_pin_hole_diameter = 1.0  # mm
standard_pin_hole_vertices = 32 # Number of vertices for the cylindrical pin holes

jumper_cutout_square_width = 3.0  # mm
pins_for_jumper_access = ["VIN", "GND1", "D1", "D2", "D7", "3V3_1"] # Use names from pin_map

wall_thickness = 2.0  # mm (wall thickness around the pin area)

# --- Calculated Dimensions (Derived from Parameters) ---
internal_pin_depth = pin_actual_exposed_length + pin_depth_clearance
total_part_height = internal_pin_depth + top_surface_thickness

# Overall length of the block of pins in a row (center of first to center of last)
pin_block_row_length = (board_config["pins_per_row"] - 1) * board_config["pin_pitch"]

# Outer dimensions of the shroud body
# Width: row_spacing + 2*(half_pin_hole_diam) + 2*(wall_thickness)
outer_shroud_width = board_config["row_spacing"] + standard_pin_hole_diameter + (2 * wall_thickness)
# Length: pin_block_row_length + 2*(half_pin_hole_diam) + 2*(wall_thickness)
outer_shroud_length = pin_block_row_length + standard_pin_hole_diameter + (2 * wall_thickness)

# --- Helper Functions ---
def clear_scene():
    """Deletes all MESH objects from the current scene."""
    if bpy.ops.object.mode_set.poll():
        bpy.ops.object.mode_set(mode='OBJECT')
    bpy.ops.object.select_all(action='DESELECT')
    bpy.ops.object.select_by_type(type='MESH')
    bpy.ops.object.delete()
    # Also clear any leftover materials or other data if necessary

def create_base_shroud(name, length, width, height):
    """Creates the main rectangular solid for the shroud."""
    bpy.ops.mesh.primitive_cube_add(
        size=1,
        enter_editmode=False,
        align='WORLD',
        location=(0, 0, height / 2.0) # Centered at Z=0 for its base
    )
    base_obj = bpy.context.active_object
    base_obj.name = name
    base_obj.dimensions = (length, width, height)
    bpy.ops.object.transform_apply(location=False, rotation=False, scale=True) # Apply scale
    return base_obj

def create_pin_hole_cutter(is_jumper, location_xy, name):
    """Creates a cutter object for a pin hole (either standard or jumper)."""
    pin_hole_loc_x, pin_hole_loc_y = location_xy

    if is_jumper:
        # Jumper cutout: Square, goes all the way through
        bpy.ops.mesh.primitive_cube_add(
            size=1, # Will be scaled
            location=(pin_hole_loc_x, pin_hole_loc_y, total_part_height / 2.0)
        )
        cutter = bpy.context.active_object
        cutter.dimensions = (jumper_cutout_square_width, jumper_cutout_square_width, total_part_height)
    else:
        # Standard pin hole: Cylinder, blind hole
        bpy.ops.mesh.primitive_cylinder_add(
            vertices=standard_pin_hole_vertices,
            radius=standard_pin_hole_diameter / 2.0,
            depth=internal_pin_depth,
            location=(pin_hole_loc_x, pin_hole_loc_y, internal_pin_depth / 2.0) # Base at Z=0
        )
        cutter = bpy.context.active_object

    cutter.name = name
    bpy.ops.object.transform_apply(location=False, rotation=False, scale=True) # Apply scale if cube
    return cutter

def apply_boolean(main_object, cutter_object, operation='DIFFERENCE'):
    """Applies a boolean modifier and removes the cutter."""
    bool_mod = main_object.modifiers.new(name="Boolean_" + cutter_object.name, type='BOOLEAN')
    bool_mod.object = cutter_object
    bool_mod.operation = operation

    # Ensure the main object is selected and active for the operator
    bpy.ops.object.select_all(action='DESELECT') # Deselect all other objects
    main_object.select_set(True)                 # Select the main object
    bpy.context.view_layer.objects.active = main_object # Set it as the active object

    # Apply the modifier using its name as a keyword argument
    try:
        bpy.ops.object.modifier_apply(modifier=bool_mod.name)
    except Exception as e:
        print(f"Error applying modifier {bool_mod.name} to {main_object.name}: {e}")
        # Optional: clean up the modifier if it failed to apply but was added
        # main_object.modifiers.remove(bool_mod) # Uncomment if you want to remove on failure
        raise # Re-raise the exception to stop the script or handle it further

    # Remove the cutter object after successful application
    bpy.data.objects.remove(cutter_object, do_unlink=True)

# --- Main Script Execution ---

# 1. Setup Scene
clear_scene()

# 2. Create Base Shroud Body
shroud_obj = create_base_shroud(
    name=f"{board_config['name']}_Shroud",
    length=outer_shroud_length,
    width=outer_shroud_width,
    height=total_part_height
)

# 3. Create and Apply Pin Holes / Cutouts
# Determine starting X and Y for pin block (center of shroud is 0,0)
start_x = -pin_block_row_length / 2.0
y_coords = [-board_config["row_spacing"] / 2.0, board_config["row_spacing"] / 2.0] # For row 0 and row 1

# Get the (row_idx, pin_idx) for jumper pins
jumper_pin_coordinates = []
for pin_name_to_find in pins_for_jumper_access:
    if pin_name_to_find in board_config["pin_map"]:
        jumper_pin_coordinates.append(board_config["pin_map"][pin_name_to_find])
    else:
        print(f"Warning: Jumper pin '{pin_name_to_find}' not found in pin_map. Skipping.")

for r_idx in range(2):  # Row index (0 or 1)
    current_y = y_coords[r_idx]
    for p_idx in range(board_config["pins_per_row"]):  # Pin index in row (0 to N-1)
        current_x = start_x + (p_idx * board_config["pin_pitch"])
        pin_location_xy = (current_x, current_y)

        # Check if current (r_idx, p_idx) is a jumper pin
        is_jumper = (r_idx, p_idx) in jumper_pin_coordinates
        
        cutter_name = f"Cutter_R{r_idx}_P{p_idx}_{'Jmp' if is_jumper else 'Std'}"
        pin_cutter = create_pin_hole_cutter(is_jumper, pin_location_xy, cutter_name)
        
        apply_boolean(shroud_obj, pin_cutter)

# 4. Final Touches (Optional)
# bpy.ops.object.modifier_add(type='BEVEL') # Example: add a small bevel
# bpy.ops.object.shade_smooth()

if flip_model_for_printing and 'shroud_obj' in locals() and shroud_obj is not None:
    print("Flipping model for printing: original solid top will become the bottom.")

    # Ensure the shroud_obj is the active and selected object for context
    # This might not be strictly necessary if shroud_obj is the only relevant object
    # but it's good practice for operators.
    bpy.ops.object.select_all(action='DESELECT')
    shroud_obj.select_set(True)
    bpy.context.view_layer.objects.active = shroud_obj

    # The object's origin is at (0, 0, total_part_height / 2.0).
    # Rotating 180 degrees around the X-axis (or Y-axis) using its current origin
    # will place its original top face (at Z=total_part_height) at the world Z=0 plane,
    # and its original bottom face (with openings, at Z=0) at world Z=total_part_height.

    # Rotate 180 degrees around the object's local X-axis
    shroud_obj.rotation_euler[0] += math.radians(180)
    
    # It's often good practice to apply the rotation if you want the object's
    # raw mesh data to reflect this new orientation permanently in Blender,
    # rather than just having a rotation transform on the object.
    # For STL export, this might not always be necessary as exporters
    # usually use the final world matrix.
    # bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)

    print(f"Model '{shroud_obj.name}' has been rotated. Its original solid top surface should now be at Z=0.")

else:
    if 'shroud_obj' in locals() and shroud_obj is not None:
        print("Model retained original orientation (pin insertion face at Z=0).")
    else:
        print("Shroud object not found for orientation check.")

print(f"--- {board_config['name']} Shroud Generation Complete ---")
print(f"Overall Dimensions (LxWxH): {outer_shroud_length:.2f} x {outer_shroud_width:.2f} x {total_part_height:.2f} mm")
print(f"Internal Pin Depth: {internal_pin_depth:.2f} mm")
print(f"Top Surface Thickness: {top_surface_thickness:.2f} mm")
print(f"Standard Pin Hole Diameter: {standard_pin_hole_diameter:.2f} mm")
print(f"Jumper Cutout Width: {jumper_cutout_square_width:.2f} mm")
print(f"Wall Thickness: {wall_thickness:.2f} mm")
print(f"Jumper access for (Row, Pin Index): {jumper_pin_coordinates}")